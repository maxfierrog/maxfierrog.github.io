<!DOCTYPE html>
<html lang="en"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
    <meta name="description" content="Max&#39;s personal site">
    
     
    <link rel="icon" type="image/x-icon" href="/favicon.ico" media="(prefers-color-scheme: light)">
    <link rel="icon" type="image/x-icon" href="/favicon-dark.ico" media="(prefers-color-scheme: dark)"> 
     
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>


    

    
    <link rel="stylesheet" href="/css/style.min.css">

    <link rel="canonical" href="http://localhost:1313/representation-concepts-in-game-theoretic-systems/" />
    <title>Representation Concepts in Game-Theoretic Systems</title>
</head>
<body><header id="banner">
    <a href="http://localhost:1313/"
        ><img src="/logo.svg" alt="Logo" class="site-logo"
    /></a>
    <h2><a href="http://localhost:1313/">Max Fierro</a></h2>
    <nav>
        <ul>
            <li>
                <a href="/about/" title="about"
                    >about</a
                >
            </li><li>
                <a href="/resume/" title="resume"
                    >resume</a
                >
            </li><li>
                <a href="/index.xml" title=""
                    >rss</a
                >
            </li>
        </ul>
    </nav>
</header>
<main id="content">
<article>
    <header id="post-header">
        <h1>Representation Concepts in Game-Theoretic Systems</h1>
        <div>
                <time>April 20, 2024</time>
            </div>
    </header><aside id="toc">
    <details>
        <summary>&nbsp;<strong> Table of contents</strong></summary>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#abstract">Abstract</a></li>
    <li><a href="#materials">Materials</a>
      <ul>
        <li><a href="#errata">Errata</a></li>
      </ul>
    </li>
    <li><a href="#background">Background</a>
      <ul>
        <li><a href="#game-theory">Game theory</a></li>
        <li><a href="#computer-science">Computer science</a></li>
      </ul>
    </li>
    <li><a href="#representation">Representation</a>
      <ul>
        <li><a href="#rulesets">Rulesets</a></li>
        <li><a href="#abstraction">Abstraction</a></li>
      </ul>
    </li>
    <li><a href="#design">Design</a>
      <ul>
        <li><a href="#interface-items">Interface items</a></li>
        <li><a href="#parallel-dp">Parallel DP</a></li>
      </ul>
    </li>
    <li><a href="#meta-content">Meta-content</a></li>
  </ul>
</nav>
    </details>
</aside>

<h2 id="abstract">Abstract</h2>
<p>I gave an introductory talk about how computer systems represent, compute, and store noteworthy attributes about a particular class of games. This was part of <a href="http://kyleburke.info/sprouts/">Sprouts &lsquo;24</a>, an undergraduate-oriented conference primarily dedicated to combinatorial game theory.</p>
<p>Here, I share the materials I used during my presentation and share a longer-form (but very different) exploration of the topic I covered. Generically, it can be useful for all problems where one must run a domain-specific algorithm on a graph that is not materialized in memory, but can be traversed in linear time from a starting node and a set of functions that derive adjacent edges and nodes from existing ones (a so-called <a href="https://en.wikipedia.org/wiki/Implicit_graph">implicit graph</a>).</p>
<p>As a concrete case of this abstract class of problems, I present concepts that support the process of finding a Nash Equilibrium for a specific subclass of games through cousins of the minimax algorithm. However, these concepts are also applicable to other such problems (e.g., the membership problem<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> for decidable subclasses of context-free grammars).</p>
<hr>
<h2 id="materials">Materials</h2>
<p>The slides I used during my talk can be found below. Anyone can use them without my permission.</p>
<script type="text/javascript" src= '/js/pdf-js/build/pdf.js'></script>

<style>
  #embed-pdf-container {
    position: relative;
    width: 100%;
    height: auto;
    min-height: 20vh;
     
  }

  .pdf-canvas {
    border: 1px solid black;
    direction: ltr;
    width: 100%;
    height: auto;
    display: none;
  }

  #the-canvas {
    border: 1px solid black;
    direction: ltr;
    width: 100%;
    height: auto;
    display: none;
  }


  .pdf-loadingWrapper {
    display: none;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 350px;
  }

  .pdf-loading {
    display: inline-block;
    width: 50px;
    height: 50px;
    border: 3px solid #d2d0d0;;
    border-radius: 50%;
    border-top-color: #383838;
    animation: spin 1s ease-in-out infinite;
    -webkit-animation: spin 1s ease-in-out infinite;
  }

  



  #overlayText {
    word-wrap: break-word;
    display: grid;
    justify-content: end;
  }

  #overlayText a {
    position: relative;
    top: 10px;
    right: 4px;
    color: #000;
    margin: auto;
    background-color: #eeeeee;
    padding: 0.3em 1em;
    border: solid 2px;
    border-radius: 12px;
    border-color: #00000030;
    text-decoration: none;
  }

  #overlayText svg {
    height: clamp(1em, 2vw, 1.4em);
    width:  clamp(1em, 2vw, 1.4em);
  }



  @keyframes spin {
    to { -webkit-transform: rotate(360deg); }
  }
  @-webkit-keyframes spin {
    to { -webkit-transform: rotate(360deg); }
  }
  </style><div class="embed-pdf-container" id="embed-pdf-container-de1ff50c">
    <div class="pdf-loadingWrapper" id="pdf-loadingWrapper-de1ff50c">
        <div class="pdf-loading" id="pdf-loading-de1ff50c"></div>
    </div>
    <canvas class="pdf-canvas" id="pdf-canvas-de1ff50c"></canvas>
</div>

<div class="pdf-paginator" id="pdf-paginator-de1ff50c">
    <button id="pdf-prev-de1ff50c">Previous</button>
    <button id="pdf-next-de1ff50c">Next</button> &nbsp; &nbsp;
    <span>
      <span class="pdf-pagenum" id="pdf-pagenum-de1ff50c"></span> / <span class="pdf-pagecount" id="pdf-pagecount-de1ff50c"></span>
    </span>
    <a class="pdf-source" id="pdf-source-de1ff50c" href="/pdf/slides-sprouts-2024.pdf">[pdf]</a>
</div>

<noscript>
View the PDF file <a class="pdf-source" id="pdf-source-noscript-de1ff50c" href="/pdf/slides-sprouts-2024.pdf">here</a>.
</noscript>

<script type="text/javascript">
    (function(){
    var url = '\/pdf\/slides-sprouts-2024.pdf';

    var hidePaginator = "" === "true";
    var hideLoader = "" === "true";
    var selectedPageNum = parseInt("") || 1;

    
    var pdfjsLib = window['pdfjs-dist/build/pdf'];

    
    if (pdfjsLib.GlobalWorkerOptions.workerSrc == '')
      pdfjsLib.GlobalWorkerOptions.workerSrc = "http:\/\/localhost:1313\/" + 'js/pdf-js/build/pdf.worker.js';

    
    var pdfDoc = null,
        pageNum = selectedPageNum,
        pageRendering = false,
        pageNumPending = null,
        scale = 3,
        canvas = document.getElementById('pdf-canvas-de1ff50c'),
        ctx = canvas.getContext('2d'),
        paginator = document.getElementById("pdf-paginator-de1ff50c"),
        loadingWrapper = document.getElementById('pdf-loadingWrapper-de1ff50c');


    
    showPaginator();
    showLoader();

    

    function renderPage(num) {
      pageRendering = true;
      
      pdfDoc.getPage(num).then(function(page) {
        var viewport = page.getViewport({scale: scale});
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        
        var renderContext = {
          canvasContext: ctx,
          viewport: viewport
        };
        var renderTask = page.render(renderContext);

        
        renderTask.promise.then(function() {
          pageRendering = false;
          showContent();

          if (pageNumPending !== null) {
            
            renderPage(pageNumPending);
            pageNumPending = null;
          }
        });
      });

      
      document.getElementById('pdf-pagenum-de1ff50c').textContent = num;
    }

    

    function showContent() {
      loadingWrapper.style.display = 'none';
      canvas.style.display = 'block';
    }

    

    function showLoader() {
      if(hideLoader) return
      loadingWrapper.style.display = 'flex';
      canvas.style.display = 'none';
    }

    

    function showPaginator() {
      if(hidePaginator) return
      paginator.style.display = 'block';
    }

    

    function queueRenderPage(num) {
      if (pageRendering) {
        pageNumPending = num;
      } else {
        renderPage(num);
      }
    }

    

    function onPrevPage() {
      if (pageNum <= 1) {
        return;
      }
      pageNum--;
      queueRenderPage(pageNum);
    }
    document.getElementById('pdf-prev-de1ff50c').addEventListener('click', onPrevPage);

    

    function onNextPage() {
      if (pageNum >= pdfDoc.numPages) {
        return;
      }
      pageNum++;
      queueRenderPage(pageNum);
    }
    document.getElementById('pdf-next-de1ff50c').addEventListener('click', onNextPage);

    

    pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
      pdfDoc = pdfDoc_;
      var numPages = pdfDoc.numPages;
      document.getElementById('pdf-pagecount-de1ff50c').textContent = numPages;

      
      if(pageNum > numPages) {
        pageNum = numPages
      }

      
      renderPage(pageNum);
    });
    })();
</script>

<h3 id="errata">Errata</h3>
<p>Here are the mistakes I have found in the slides:</p>
<ol>
<li>In slide 10, the first bullet point should also restrain the set of games under consideration to be extensive-form and non-collaborative, as implied by the subsequent definition in slides 11-15.</li>
<li>In slide 20, the formulation $\langle N, S, p, u \rangle$ should also include a transition function $t : S \to \mathcal{P}(S)$, where if $s$ is a state corresponding to history $h$, then the history $h&rsquo;$ corresponding to $s&rsquo;$ should be the same as $h$ with an additional action appended for all $s&rsquo; \in t(s)$.</li>
<li>In slide 28, the partition should not necessarily minimize the sum of the conductance of all cuts that produce the partition. Instead, the ideal partition would be a solution to the <a href="https://en.wikipedia.org/wiki/Graph_partition#:~:text=%5B4%5D-,Problem,-%5Bedit%5D">balanced partition problem</a>, where optimal parameters are determined from hardware-related constraints (such as the cost of inter-process communication). The goal is to balance parallelism with its own overhead.</li>
</ol>
<hr>
<h2 id="background">Background</h2>
<p>In the interest of accessibility, I will briefly cover useful basics in game theory and computer science that seldom find their way into students&rsquo; syllabi or are otherwise worth refreshing. If you think you can safely skip this, you are probably right.</p>
<h3 id="game-theory">Game theory</h3>
<p>The generic setup of a game is some amount of &ldquo;players&rdquo; taking actions according to their own interests or preferences, potentially affecting other players in the process. From the point of view of a single player, a game is an optimization problem that seeks to find an &ldquo;optimal strategy&rdquo; from the information available to them. This is an assumption known as &ldquo;individual rationality&rdquo; that pervades most of game theory.</p>
<p>But from a global point of view, there is no obvious question to ask about a game. This is why games are not problems; they are situations that we can ask different questions about. But <em>per se</em>, games are not aching to be solved. To ask specific questions with some hope of rigor, a lot of effort has been placed into defining classes of games that posses different characteristics.</p>
<h4 id="taxonomy-of-games">Taxonomy of games</h4>
<p>There are a lot of classes of games. They are separated by the mathematical properties of their setting and participants, among other factors.</p>
<p>There is no global dictionary or atlas for game classes, as interpretations can become nuanced to the extent of opinion. Hence, anytime someone makes a statement in game theory they must specify the class of games it targets. In this article, we will target games that are:</p>
<ol>
<li>
<p><strong>Perfect-information.</strong> Here, all players know everything in the universe that could possibly help them make or avoid any decision, except the decisions that other players will make. Most forms of Poker are not perfect-information, as the exact location of the cards is unknown.</p>
</li>
<li>
<p><strong>Deterministic.</strong> Here, if all players choose a strategy and never change it, there is only one possible outcome for the game. Chess is deterministic, because if players make the exact same moves in two different games they are guaranteed to achieve the same result.</p>
</li>
<li>
<p><strong>Sequential.</strong> More intuitive superset of <a href="https://cdn.nba.com/headshots/nba/latest/1040x760/2544.png" style="color: inherit; text-decoration: none">extensive-form games</a>. Here, all actions that players can take are indivisible. Soccer is not discrete, because players&rsquo; movements constitute their actions and it is possible to divide any movement into a shorter one.</p>
</li>
<li>
<p><strong>Extensive-form.</strong> The adjective &ldquo;extensive-form&rdquo; refers to games that can be written in extensive form, which is a kind of mathematical template. Here, games are defined in terms of the histories of actions that could be observed by the players, and the preferences each player has among them.</p>
</li>
</ol>
<h4 id="solution-concepts">Solution concepts</h4>
<p>There are some questions that are so broadly-applicable in terms of the classes of games they can target that they achieve the special status of a <strong>solution concept.</strong> This is a term that refers to a characteristic can be observed in a useful set of game classes.</p>
<p>A very human thing to ask about broad categories of games is who will win. As it turns out, there is no real answer to this question most of the time, because it can come across obstacles like chance, incomplete information, and lack of clarity around the word &ldquo;win.&rdquo; An equally important yet more applicable question, however, is what strategy each player should take to achieve the best possible result for themselves.</p>
<p>In many cases, it is necessary to tack on additional nuances to this question to be able to answer it. One such refinement of the question (which revolutionized economics) asks which strategy each player should adopt so that no single player could change their own and benefit from it. A pairing of players to strategies is known as a <strong>strategy profile</strong>, and those that satisfy the above property are known as <strong>Nash Equilibria</strong>.</p>
<p>The strategies and strategy profiles that allow players to act probabilistically are called <strong>mixed</strong>. Mixed strategies are tantamount to sampling <a href="https://en.wikipedia.org/wiki/Probability_distribution">probability distributions</a> of <strong>pure strategies</strong>, which themselves specify deterministic actions. In 1950, John Nash defined the concept of a Nash Equilibrium (NE), additionally proving that there exists such a mixed strategy profile in all games <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>.</p>
<style>
    .box-body > :last-child {
        margin-bottom: 0 !important;
    }

    .box-body > :first-child {
        margin-top: 0 !important;
    }
</style>
<div
    class="hint-box"
    style="
        border: 1px solid #000000;
        padding: 10px;
        border-radius: 5px;
        margin: 16px 0;
        background-color: rgba(0, 0, 0, 0.05);
    "
>
    <strong style="display: block; margin-bottom: 5px"
        >Note</strong
    >
    <hr
        style="
            border: none;
            border-top: 1px solid #000000;
            margin: 10px 0;
            width: calc(100%);
        "
    />
    <div style="font-size: 0.92em" class="box-body">
<p>Nash Equilibrium is an overloaded term, as it refers to both a solution concept and a strategy profile that satisfies the solution concept. You will need to tell which is which from context.</p>
</div>
</div>
<h3 id="computer-science">Computer science</h3>
<p>The possibility of players taking actions simultaneously (among other things) can make the existence of a pure-strategy NE impossible. But if sequential play is assumed, it is straightforward to show that there always exists a pure-strategy NE <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>. As mentioned above, this article benefits from this assumption.</p>
<p>Because finding a NE is such a popular desire, most of the discussion here will focus on the procedure of finding a pure-strategy NE in the class of games we specified previously. This is a costly process, which is why it calls for techniques that help minimize use of computational resources. However, you will notice that the things that make this an inherently costly process for some games are actually factors that have nothing to do with game theory.</p>
<p>Hence, it is possible that the concepts I will discuss are applicable beyond the problem of finding a pure-strategy NE. To elaborate, a maximally generic yet snobby version of this article would perhaps be titled <em>Techniques for Implementing Solutions to Search Problems on Implicit Graphs</em>. The meanings of these terms are:</p>
<ol>
<li>
<p><strong>Implementing.</strong> Bring into the real world.</p>
</li>
<li>
<p><strong>Solutions.</strong> In this context, algorithms that solve problems.</p>
</li>
<li>
<p><strong>Search Problem.</strong> A problem that asks you to find something.</p>
</li>
<li>
<p><strong>Implicit Graph.</strong> <a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type)">Graph</a> representation in terms of an initial element and a collection of functions which allow you to perform a traversal. Useful but unconventional term.</p>
</li>
</ol>
<p>In particular, the section titled &ldquo;Representation&rdquo; will explain the link between the definition of an extensive game and the representation of its structure as an implicit graph, and will introduce a trick that can be used to end up with a significantly simpler traversals. This trick is also applicable to problem domains other than games, but I only present it with regard to games because its implementation depends on the underlying problem. Everything else is applicable as soon as you have an implicit graph in your hands.</p>
<p>While explaining these concepts, it will be useful to have access to ideas in complexity theory. Below are some domain-specific remarks and definitions introducing language that will be of relevance later.</p>
<h4 id="complexity-theory">Complexity theory</h4>
<p>In computer science, complexity is a measure<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup> of the minimal number of elementary operations that must be composed to complete a target operation. The relevant elementary operations correspond to the kind of complexity in question:</p>
<ol>
<li>
<p><strong>Time complexity.</strong> Here, elementary operations are other operations whose time is assumed to be a known constant. Elementary operations should always be specified.</p>
</li>
<li>
<p><strong>Space complexity.</strong> Here, the elementary operation is setting a bit. A more formal definition of space complexity depends on the <a href="https://en.wikipedia.org/wiki/Model_of_computation">model of computation</a>.</p>
</li>
</ol>
<p>For the sake of expressibility, complexity is usually expressed in terms of <a href="https://en.wikipedia.org/wiki/Asymptotic_analysis">asymptotic characteristics</a>. In particular, symbolisms like <a href="https://web.mit.edu/16.070/www/lecture/big_o.pdf">Big-O notation</a> help compare the asymptotic complexity of different algorithms.</p>
<p><a href="https://en.wikipedia.org/wiki/Computational_problem">Computational problems</a> can be put into <a href="https://en.wikipedia.org/wiki/Complexity_class">complexity classes</a>. For example, the problem of finding a mixed-strategy NE, known as $\text{N}\small{\text{ASH}}$, is in the time complexity class <a href="https://en.wikipedia.org/wiki/FNP_(complexity)">$\text{FNP}$</a>, which has led many people to look for other solution concepts that are more computationally favorable<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>. The equivalent problem for the class of games we are considering, however, is in <a href="https://en.wikipedia.org/wiki/FP_(complexity)">$FP$</a>. In other words, $\text{N}\small{\text{ASH}}$ can be solved <a href="https://en.wikipedia.org/wiki/Algorithmic_efficiency">efficiently</a> on this restricted domain of games<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>.</p>
<hr>
<h2 id="representation">Representation</h2>
<p>One can find solutions to instances of many search and decision problems over games without incurring large computational expenses. This is possible by deriving a logical analysis on a case-by-case basis, using the mathematical properties of the components of the game in question.</p>
<style>
    .box-body > :last-child {
        margin-bottom: 0 !important;
    }

    .box-body > :first-child {
        margin-top: 0 !important;
    }
</style>
<div
    class="hint-box"
    style="
        border: 1px solid #000000;
        padding: 10px;
        border-radius: 5px;
        margin: 16px 0;
        background-color: rgba(0, 0, 0, 0.05);
    "
>
    <strong style="display: block; margin-bottom: 5px"
        >Definition</strong
    >
    <hr
        style="
            border: none;
            border-top: 1px solid #000000;
            margin: 10px 0;
            width: calc(100%);
        "
    />
    <div style="font-size: 0.92em" class="box-body">
<p>An <strong>extensive-form game</strong> is a 4-tuple $\langle N, H, p, (\succsim_i) \rangle$, where:</p>
<ul>
<li>$N$ is a set of players, usually $\{1, \; \ldots, \; n\}$ for simplicity.</li>
<li>$H$ is a set of strings of actions where $h \in H \implies h&rsquo; \in H$ where $h&rsquo;$ is the string resulting from removing the last action from the string $h$.</li>
<li>$p : H \to N$ assigns a player to each non-terminal history.</li>
<li>The player $i \in N$ has a preference relation $\succsim_i$ on the set $Z \subseteq H$ of terminal histories (which is reflexive and transitive).</li>
</ul>
</div>
</div>
<p>For a game provided in the extensive form, its instantiation of the above abstractions can be logically leveraged to prove statements about the game. But given that it can be defined arbitrarily, sometimes it is impossible to achieve this solely through formal rewriting.</p>
<p>In some of these cases it is possible to simply expand the component definitions into their explicit forms in order to later compute a solution using these expansions. But of course, doing this can also be extremely impractical. For example, it is common for $H$ to be of very high cardinality.</p>
<style>
    .box-body > :last-child {
        margin-bottom: 0 !important;
    }

    .box-body > :first-child {
        margin-top: 0 !important;
    }
</style>
<div
    class="hint-box"
    style="
        border: 1px solid #000000;
        padding: 10px;
        border-radius: 5px;
        margin: 16px 0;
        background-color: rgba(0, 0, 0, 0.05);
    "
>
    <strong style="display: block; margin-bottom: 5px"
        >Example</strong
    >
    <hr
        style="
            border: none;
            border-top: 1px solid #000000;
            margin: 10px 0;
            width: calc(100%);
        "
    />
    <div style="font-size: 0.92em" class="box-body">
<p>Consider a <a href="https://en.wikipedia.org/wiki/Rubik%27s_Cube">Rubik&rsquo;s Cube</a> that is initialized to specific starting colors, which can be set into the extensive form via the following instantiations:</p>
<ul>
<li>$N = \{1\}$.</li>
<li>$H = \{ h \; | \; h \text{ is a sequence of 90Â° rotations of a plane in the cube} \}$.</li>
<li>$p : h \mapsto 1$ for all $h \in H$.</li>
<li>$h_i \succsim_1 h_j$ for all $h_i$ that leave the cube solved.</li>
</ul>
<p>Here, the set $H$ is countably infinite, so it is impossible to expand it to its elements in order to later compute a property of this puzzle. One such property is the smallest number of actions that can solve the cube<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup>.</p>
</div>
</div>
<h3 id="rulesets">Rulesets</h3>
<p>Before introducing tools to deal with this, there is another representation that is common when dealing with <a href="https://en.wikipedia.org/wiki/Abstract_strategy_game">abstract strategy games</a>. A ruleset, as it is known in <a href="https://en.wikipedia.org/wiki/Combinatorial_game_theory">combinatorial game theory</a>, is the most familiar kind of representation of a game.</p>
<p>In particular, a ruleset specifies exactly what actions are permitted to whom and when. It also explains the <a href="https://en.wikipedia.org/wiki/Utility">utility</a> obtained by each participating player when no further actions are available. These characteristics are expressed in terms of the mutable state of a proxy (e.g., a board with pieces).</p>
<style>
    .box-body > :last-child {
        margin-bottom: 0 !important;
    }

    .box-body > :first-child {
        margin-top: 0 !important;
    }
</style>
<div
    class="hint-box"
    style="
        border: 1px solid #000000;
        padding: 10px;
        border-radius: 5px;
        margin: 16px 0;
        background-color: rgba(0, 0, 0, 0.05);
    "
>
    <strong style="display: block; margin-bottom: 5px"
        >Example</strong
    >
    <hr
        style="
            border: none;
            border-top: 1px solid #000000;
            margin: 10px 0;
            width: calc(100%);
        "
    />
    <div style="font-size: 0.92em" class="box-body">
<p>The game <code>10-to-0-by-1-or-2</code> is generated by the following ruleset:</p>
<ul>
<li>There is a collection of 10 items.</li>
<li>2 players take alternating turns removing either 1 or 2 items from the collection.</li>
<li>Player 1 starts. The player who takes the last item from the collection wins.</li>
</ul>
<p>In this game, the collection of items that is mutated by players&rsquo; actions is a proxy that allows players to judge what they are allowed to do and to determine who wins the game.</p>
</div>
</div>
<p>This way, the information contained in the state of a proxy is a representation of the history of actions that produced it. These representations are called <strong>game states</strong>. This makes rulesets implicit graphs over the set of game states (denoted $S$). While they do not act directly over a set of histories, rulesets include enough information to generate an equivalent extensive-form representation. The resulting structure of generated action histories is hence intimately tied to the nature of the proxy.</p>
<style>
    .box-body > :last-child {
        margin-bottom: 0 !important;
    }

    .box-body > :first-child {
        margin-top: 0 !important;
    }
</style>
<div
    class="hint-box"
    style="
        border: 1px solid #000000;
        padding: 10px;
        border-radius: 5px;
        margin: 16px 0;
        background-color: rgba(0, 0, 0, 0.05);
    "
>
    <strong style="display: block; margin-bottom: 5px"
        >Definition</strong
    >
    <hr
        style="
            border: none;
            border-top: 1px solid #000000;
            margin: 10px 0;
            width: calc(100%);
        "
    />
    <div style="font-size: 0.92em" class="box-body">
<p>Given a directed graph $G = \langle S, E \rangle$, the corresponding <strong>implicit graph</strong> $G^I$ is a 3-tuple $\langle S, t, s_0 \rangle$, where:</p>
<ul>
<li>$S$ is a set of states.</li>
<li>$s_0 \in S$ is a starting element.</li>
<li>$t : S \to \mathcal{P}(S)$ is a transition dynamics function with $(s_i, s_j) \in E \iff s_j \in t(s_i)$.</li>
</ul>
<p>A proof of the bijection between implicit and directed graphs is omitted.</p>
</div>
</div>
<p>Furthermore, because many actions could be globally or locally commutative with respect to proxies&rsquo; mutable state, sets of histories in the extensive form are usually of much higher cardinality than sets of possible states for rulesets&rsquo; proxies. This is of course computationally favorable, as finite ruelesets (whose proxies have a finite number of possible states) can generate even infinite extensive forms.</p>
<style>
    .box-body > :last-child {
        margin-bottom: 0 !important;
    }

    .box-body > :first-child {
        margin-top: 0 !important;
    }
</style>

<div
    class="hint-box"
    style="
        border: 1px solid #000000;
        padding: 10px;
        border-radius: 5px;
        margin: 16px 0;
        background-color: rgba(0, 0, 0, 0.05);
    "
>
    <strong style="display: block; margin-bottom: 5px"
        >Example</strong
    >
    <hr
        style="
            border: none;
            border-top: 1px solid #000000;
            margin: 10px 0;
            width: calc(100%);
        "
    />
    <div style="font-size: 0.92em" class="box-body">
<style>
    .book-column > :first-child:not(.halign-container, .valign-container) {
        margin-top: 0px !important;
    }

    .book-column > :last-child:not(.halign-container, .valign-container) {
        margin-bottom: 0px !important;
    }
</style>
<div style="display: flex; flex-wrap: wrap">
       
    <div class="book-column" style="flex: 9;">
        <p>In the diagram to the right, let $S_0$, $S_1$, $S_2$, and $S_3$ be allowed states under a ruleset, and $A = \{a, b\}$ allowed actions. We have that:</p>
<ul>
<li>The set of histories is $H = \{ \epsilon, a, b, ab, ba \}$.</li>
<li>The set of states is $S = \{ S_0, S_1, S_2, S_3 \}$.</li>
</ul>
<p>As you can see, $|H| &gt; |S|$ despite how $|A| &lt; |S|$. The difference in size between $H$ and $S$ scales rapidly in the general case.</p>

    </div>
     
    <div class="book-column" style="flex: 5;">
        <style>
    .valign-container {
        display: flex;
        height: 100%;
        align-items: center;  
    }
</style>
<div class="valign-container">
<style>
    .halign-container {
        display: flex;
        width: 100%;
        justify-content: center;  
    }
</style>
<div class="halign-container">
<figure>
    <img loading="lazy" src="commutative_diagram.png" width="128"/> 
</figure>
</div>
</div>

    </div>
    
</div>


</div>
</div>

<h3 id="abstraction">Abstraction</h3>
<p>In real life, games come mostly in the form of rulesets. We are usually aware of the environment they transpire in (the so-called intuitive proxy) and the laws that describe how it can change as a function of players&rsquo; actions. Because of this, much of applied theory is centered around semantics that involve mutable state. For example, a <a href="https://en.wikipedia.org/wiki/Markov_decision_process">Markov Decision Process (MDP)</a> from <a href="https://en.wikipedia.org/wiki/Reinforcement_learning">reinforcement learning</a> strongly reflects the nature of a ruleset.</p>
<p>However, all of these constructs have a latent yet equivalent extensive form representation. This will motivate the technique of <strong>state abstraction</strong><sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup>: The necessity for action histories to be directly prefixed implies that they have a directed tree structure, and because all directed graphs have an equivalent implicit graph representation, the relationship between action histories and ruleset states maps an implicit graph to another one that retains important information about the original.</p>
<style>
    .box-body > :last-child {
        margin-bottom: 0 !important;
    }

    .box-body > :first-child {
        margin-top: 0 !important;
    }
</style>
<div
    class="hint-box"
    style="
        border: 1px solid #000000;
        padding: 10px;
        border-radius: 5px;
        margin: 16px 0;
        background-color: rgba(0, 0, 0, 0.05);
    "
>
    <strong style="display: block; margin-bottom: 5px"
        >Definition</strong
    >
    <hr
        style="
            border: none;
            border-top: 1px solid #000000;
            margin: 10px 0;
            width: calc(100%);
        "
    />
    <div style="font-size: 0.92em" class="box-body">
<p>An <strong>abstraction map</strong> $a : S_{\text{pre}} \to S_{\text{post}}$ maps the states in an implicit graph $G^I_{\text{pre}}$ to the states in another implicit graph $G^I_{\text{post}}$ with the structure-preserving condition</p>
$$ s_j \in t_{\text{pre}}(s_i) \iff a(s_j) \in t_{\text{post}}(a(s_i)). $$</div>
</div>
<p>As shown in the last example, the set of action histories is usually of much greater cardinality than its corresponding set of ruleset states, with the difference being possibly infinite. Altogether, this is a hint that, much like the implicit jump from action histories to ruleset states, it is possible to jump to more abstract state sets of smaller cardinality but equal representational power.</p>
<style>
    .box-body > :last-child {
        margin-bottom: 0 !important;
    }

    .box-body > :first-child {
        margin-top: 0 !important;
    }
</style>

<div
    class="hint-box"
    style="
        border: 1px solid #000000;
        padding: 10px;
        border-radius: 5px;
        margin: 16px 0;
        background-color: rgba(0, 0, 0, 0.05);
    "
>
    <strong style="display: block; margin-bottom: 5px"
        >Example</strong
    >
    <hr
        style="
            border: none;
            border-top: 1px solid #000000;
            margin: 10px 0;
            width: calc(100%);
        "
    />
    <div style="font-size: 0.92em" class="box-body">

<p>An abstraction mapping between the action histories (left) and states (right) from the previous example. Notice how action histories always imply a tree, and the process of abstraction folds it into a potentially cyclic graph.</p>
<p><a href=""></a> <!-- This is for rendering the above as a <p> element --></p>



<style>
    .halign-container {
        display: flex;
        width: 100%;
        justify-content: center;  
    }
</style>
<div class="halign-container">
<figure>
    <img loading="lazy" src="abstraction.png" width="475"/> 
</figure>

</div>


</div>
</div>

<p>Therefore, much like imposing a ruleset proxy causes many of the action histories to fold into equivalent states, we can determine for a problem $\text{P}$ which states would be $\text{P}$-equivalent under the ruleset&rsquo;s laws. This way, we can create new abstractions $a_i : S_{i - 1} \to S_i$ that can be composed to obtain a reduced state space that is equivalent to the original under $\text{P}$ for a significant computational upside.</p>
<style>
    .box-body > :last-child {
        margin-bottom: 0 !important;
    }

    .box-body > :first-child {
        margin-top: 0 !important;
    }
</style>
<div
    class="hint-box"
    style="
        border: 1px solid #000000;
        padding: 10px;
        border-radius: 5px;
        margin: 16px 0;
        background-color: rgba(0, 0, 0, 0.05);
    "
>
    <strong style="display: block; margin-bottom: 5px"
        >Example</strong
    >
    <hr
        style="
            border: none;
            border-top: 1px solid #000000;
            margin: 10px 0;
            width: calc(100%);
        "
    />
    <div style="font-size: 0.92em" class="box-body">
<p>Consider the ruleset underlying the game of Tic-Tac-Toe. Denote $B_i$ a board state. Then, any algorithm that computes a NE for this game through its ruleset is invariant to the abstraction $a$, where</p>
$$ a(B_i) = a(B_j) \iff B_i \text{ is symmetrical to } B_j. $$<p>Further, the number of board states this algorithm will need to visit is reduced by a factor $&gt;5$.</p>
</div>
</div>
<hr>
<h2 id="design">Design</h2>
<p>So far, discussion has brought us to implicit graphs and abstractions through the lens of game theory. The objective of this section will be to motivate these concepts beyond game theory, while supplying references to concrete programming ideas.</p>
<p>To do this, we will cover a representation of an implicit graph in a real programming language, apply it to a new problem domain, and make improvements that bring real-world utility. Examples will still be given in terms of games, as they also happen to fit under our new focus. In doing so, we will design a solution to a broad problem using our new toolset items.</p>
<h3 id="interface-items">Interface items</h3>
<p>There are a number of considerations to make when encoding an implicit graph, whose importance will vary depending on the object being represented. This section will introduce only the example of graphs of subproblems in the context of <a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a> (DP), and will iterate on the following <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Rust interface</a> to eventually allow their solutions to be found in parallel through a special kind of abstraction.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">trait</span><span class="w"> </span><span class="n">ImplicitGraph</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">C</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">State</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">type</span> <span class="nc">State</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">start</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">State</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">transition</span><span class="p">(</span><span class="n">state</span>: <span class="nc">Self</span>::<span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">C</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>The elements of this interface declaration relate to the implicit graph $G^I = \langle S, t, s_0 \rangle$ as follows:</p>
<ul>
<li>The generic parameter <code>Start</code> is the type of the elements in $S$.</li>
<li>The generic parameter <code>C</code> is the type of the elements in $\mathcal{P}(S)$.</li>
<li><code>transition</code> is the template of $t$.</li>
<li><code>start</code> simply returns $s_0$.</li>
</ul>
<style>
    .box-body > :last-child {
        margin-bottom: 0 !important;
    }

    .box-body > :first-child {
        margin-top: 0 !important;
    }
</style>
<div
    class="hint-box"
    style="
        border: 1px solid #000000;
        padding: 10px;
        border-radius: 5px;
        margin: 16px 0;
        background-color: rgba(0, 0, 0, 0.05);
    "
>
    <strong style="display: block; margin-bottom: 5px"
        >Example</strong
    >
    <hr
        style="
            border: none;
            border-top: 1px solid #000000;
            margin: 10px 0;
            width: calc(100%);
        "
    />
    <div style="font-size: 0.92em" class="box-body">
<p>Implementation of the game <code>10-to-0-by-1-or-2</code> from the section on Rulesets as an implicit graph.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="sd">/// The game `10-to-0-by-1-or-2`.
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">struct</span> <span class="nc">ZeroBy</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">ImplicitGraph</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ZeroBy</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// Tuple of (items, turn).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">type</span> <span class="nc">State</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// Returns (10 items left, player 0&#39;s turn).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">fn</span> <span class="nf">start</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// Returns states with one and two less items on the opposing player&#39;s turn.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">fn</span> <span class="nf">transition</span><span class="p">(</span><span class="n">state</span>: <span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">,</span><span class="w"> </span><span class="n">turn</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="n">next</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="n">turn</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="n">next</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">items</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="n">turn</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="n">next</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">items</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="n">turn</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">next</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
<h3 id="parallel-dp">Parallel DP</h3>
<p>A popular characterization of DP is to establish dependency <a href="https://en.wikipedia.org/wiki/Relation_(mathematics)">relations</a> on sets of subproblems, defining a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a> (DAG) for any properly formulated subproblem definition. A natural link to implicit graphs exists through their bijection with general graphs.</p>
<p>Having established that a DP problem can be characterized as an implicit graph of subproblems, it is also worth mentioning that most unorganized solution implementations (i.e., that do not organize solutions or information about subproblems in a tensor) make use of stack-like data structures to aid traversals of subproblems in <a href="https://en.wikipedia.org/wiki/Tree_traversal">postorder</a>.</p>
<style>
    .box-body > :last-child {
        margin-bottom: 0 !important;
    }

    .box-body > :first-child {
        margin-top: 0 !important;
    }
</style>
<div
    class="hint-box"
    style="
        border: 1px solid #000000;
        padding: 10px;
        border-radius: 5px;
        margin: 16px 0;
        background-color: rgba(0, 0, 0, 0.05);
    "
>
    <strong style="display: block; margin-bottom: 5px"
        >Example</strong
    >
    <hr
        style="
            border: none;
            border-top: 1px solid #000000;
            margin: 10px 0;
            width: calc(100%);
        "
    />
    <div style="font-size: 0.92em" class="box-body">
<p>DP algorithm to compute who will win a game of <code>10-to-0-by-1-or-2</code>, with the below subproblem relation<sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup>:</p>
$$ W(s) = \max_{s' \in \\, t(s)} \min_{s' \in \\, t(s)} W(s'). $$<p>Here, $W : S \to \{ 0, \, 1 \} $ maps state information (including the number of items remaining and player turn) to whether the player whose turn it is at $s$ would win under optimal play, with $t$ being the transition function of the implicit graph over this game&rsquo;s states. This uses the implementation from the previous example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">procedure:
</span></span><span class="line"><span class="cl">  temp â empty stack
</span></span><span class="line"><span class="cl">  stack â empty stack
</span></span><span class="line"><span class="cl">  visited â empty set
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  stack.push(ZeroBy::start())
</span></span><span class="line"><span class="cl">  while stack is not empty:
</span></span><span class="line"><span class="cl">    current â stack.pop()
</span></span><span class="line"><span class="cl">    if current is not in visited:
</span></span><span class="line"><span class="cl">      visited.add(current)
</span></span><span class="line"><span class="cl">      temp_stack.push(current)
</span></span><span class="line"><span class="cl">      for each state in ZeroBy::transition(current):
</span></span><span class="line"><span class="cl">        if state is not in visited:
</span></span><span class="line"><span class="cl">          stack.push(state)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  solution â empty map
</span></span><span class="line"><span class="cl">  while temp_stack is not empty:
</span></span><span class="line"><span class="cl">    current â temp_stack.pop()
</span></span><span class="line"><span class="cl">    solution[current] = W(current)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  return solution[ZeroBy::start()]</span></span></code></pre></td></tr></table>
</div>
</div>
<p>Note the use of $W$ in line 19. Also note that the subproblem relation does not necessarily generalize to other games and, for the sake of brevity, is not defined for base cases (where $t(s) = \varnothing$).</p>
</div>
</div>
<p>Attempts to parallelize this setup must first identify a method to partition the subproblem graph in a way optimizes the tradeoff between parallelism and its own overhead. Of course, this depends significantly on the specific resources that will be used to execute the resulting program.</p>
<p>I will introduce one way of doing this that follows naturally from the use of the implicit graph interface. Concretely, a carefully chosen abstraction $\pi : S \to \mathbb{N}$ that connects the graph of subproblems to a DAG of enumerated sets of states will provide a parallelization scheme.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">trait</span><span class="w"> </span><span class="n">ImplicitGraph</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">C</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">State</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">type</span> <span class="nc">State</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">start</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">State</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">partition</span><span class="p">(</span><span class="n">state</span>: <span class="nc">Self</span>::<span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;-- NEW
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">fn</span> <span class="nf">transition</span><span class="p">(</span><span class="n">state</span>: <span class="nc">Self</span>::<span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">C</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>Here, <code>partition</code> is the template of $\pi$. The big idea is that during a traversal, we can observe a change in the value of <code>*::partition(current)</code>, where <code>current</code> is the current state in the traversal. This way, we can build a graph of the outputs of this function based on their adjacency in the subproblem graph. Finally, we analyze the resulting graph to find sets of states that can be traversed simultaneously.</p>
<style>
    .box-body > :last-child {
        margin-bottom: 0 !important;
    }

    .box-body > :first-child {
        margin-top: 0 !important;
    }
</style>
<div
    class="hint-box"
    style="
        border: 1px solid #000000;
        padding: 10px;
        border-radius: 5px;
        margin: 16px 0;
        background-color: rgba(0, 0, 0, 0.05);
    "
>
    <strong style="display: block; margin-bottom: 5px"
        >Example</strong
    >
    <hr
        style="
            border: none;
            border-top: 1px solid #000000;
            margin: 10px 0;
            width: calc(100%);
        "
    />
    <div style="font-size: 0.92em" class="box-body">
<p>On the left, a graph over a set of states $S = \{ s_0, \, \ldots, \, s_{11} \}$. On the right, a graph over a set $\Pi \subset \mathbb{N}$ with four elements. They are related by an abstraction $\pi : S \to \Pi$ that is special in that the resulting graph over the elements of $\Pi$ is acyclic. Hence, the <a href="https://en.wikipedia.org/wiki/Fiber_(mathematics)">fibers</a> $\pi^{-1}(\{\pi_i\})$ of certain distinct elements $(\pi_i)$ of $\Pi$ could possibly be traversed in parallel. An example of groupings of elements in  $\Pi$ whose fibers under $\pi$ could be traversed in parallel is provided in dotted boxes on the graph of $\Pi$.</p>
<figure>
    <img loading="lazy" src="partition.png" width="550"/> 
</figure>
</div>
</div>
<p>Finding a suitable $\pi$ depends on the chosen state (subproblem) representation and is of course highly problem-specific. However, a general strategy is to ensure that $\pi$ outputs a different label if and only if an irreversible change is made to some form of mutable state. As a high-level criterion, this helps construct an abstraction that assuredly maps onto a DAG.</p>
<p>Having found such an abstraction, the next perplexity of parallelizing a postorder traversal of subproblems is managing efficient and clear use of shared data structures. Here, a zoo of approaches with varyingly personable tradeoffs are available. I will introduce only one, which involves an additional interface item in the form of a function $t&rsquo; : S \to \mathcal{P}(S)$ called <code>retrograde</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">trait</span><span class="w"> </span><span class="n">ImplicitGraph</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">C</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">State</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">type</span> <span class="nc">State</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">start</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">State</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">partition</span><span class="p">(</span><span class="n">state</span>: <span class="nc">Self</span>::<span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u64</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">transition</span><span class="p">(</span><span class="n">state</span>: <span class="nc">Self</span>::<span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">C</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">retrograde</span><span class="p">(</span><span class="n">state</span>: <span class="nc">Self</span>::<span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">C</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;-- NEW
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>In an ideal world, <code>retrograde</code> is the equivalent of <code>transition</code> for the <a href="https://en.wikipedia.org/wiki/Transpose_graph">transpose</a> of the graph being represented. Unfortunately, it is not generally tractable to have a perfect implementation of <code>retrograde</code> without first materializing the entire graph (defeating the purpose of an implicit graph representation). Thus, we only make sure that <code>retrograde</code> returns a superset of what <code>transition</code> would return for the transpose of the graph, which is easy to ensure in many useful cases.</p>
<p>With $\pi$ and $t&rsquo;$ in our hands, we can provision the following procedure for parallelizing the execution of an unorganized dynamic programming algorithm over an implicit graph $G^I$ of subproblems:</p>
<style>
    .box-body > :last-child {
        margin-bottom: 0 !important;
    }

    .box-body > :first-child {
        margin-top: 0 !important;
    }
</style>
<div
    class="hint-box"
    style="
        border: 1px solid #000000;
        padding: 10px;
        border-radius: 5px;
        margin: 16px 0;
        background-color: rgba(0, 0, 0, 0.05);
    "
>
    <strong style="display: block; margin-bottom: 5px"
        >Procedure</strong
    >
    <hr
        style="
            border: none;
            border-top: 1px solid #000000;
            margin: 10px 0;
            width: calc(100%);
        "
    />
    <div style="font-size: 0.92em" class="box-body">
<ol>
<li>Traverse $G^I$ to obtain the set of subproblems $S$ in $\mathcal{\Theta}(|G^I|)$ time and $\mathcal{\Theta}(|S|)$ space.</li>
<li>During (1), track the subset of subproblems $S_{base} = \{ s \; | \; t(s) = \varnothing \}$ at no additional cost.</li>
<li>During (1), construct a graph $G_\Pi$ over a set of partition labels $\Pi$ using $\pi$, at a $\pi$-dependent cost.</li>
<li>Use $G_\Pi$ to generate a plan<sup id="fnref:10"><a href="#fn:10" class="footnote-ref" role="doc-noteref">10</a></sup> of labeled parallel tasks in $\mathcal{\Theta}(|G_\Pi|)$ time and $\mathcal{\Theta}(|\Pi|)$ space.</li>
<li>Delegate tasks, starting exploration from popped elements of $S_{base}$ with the task&rsquo;s label.</li>
<li>Use $t&rsquo;$ for backward intra-partition traversal (using $S$ for existence checks) in $t&rsquo;$-dependent time.</li>
<li>When a change in $\pi(s)$ is observed on the current state $s$, add $s$ to $S_{base}$, leaving it unexplored.</li>
<li>When a partition is completely explored, finish its task and free the parallel unit.</li>
<li>Repeat from (5) on new elements of $S_{base}$ until there are no tasks remaining.</li>
</ol>
</div>
</div>
<p>These general steps skip some details, but they present an arbitrarily parallel stack-free traversal that can be implemented over a single shared data structure whose size scales in the order of $\mathcal{\Theta}(|S|)$ (ignoring structures related to partitions, whose size is assumed to be negligible). This kind of map-like <a href="https://en.wikipedia.org/wiki/Thread_safety">thread-safe</a> functionality is available in many database implementations which automatically bring the added benefit of disk usage, making this method applicable to &ldquo;bigger&rdquo; problems.</p>
<hr>
<h2 id="meta-content">Meta-content</h2>
<p>The section titled &ldquo;Representation&rdquo; got us to stumble across the new concepts of implicit graphs and abstractions by looking at different forms for game representations. The following section extrapolated these ideas to the domain of dynamic programming, and showed how it is possible to incorporate them into the design of solutions to real-world problems.</p>
<p>Something interesting is that games made their way into the second section, despite being decidedly out of scope at that point. In a dying hope of getting this article back on track, I will point out that the particular example of parallelizing DP algorithms was conveniently chosen because it is used to <a href="https://en.wikipedia.org/wiki/Solved_game">solve</a> bigger games faster than was previously possible (through DP algorithms that consume representations of them).</p>
<p>This way, I can say that this whole article was in fact about game-theoretic systems. But we both know that it was really about implicit graphs and abstractions. Maybe, if we squint our eyes, it can be about both topics. Either way, I hope the lack of clarity was more stimulating than it was confusing.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>The problem of deciding whether or not a string is in the language of a context-free grammar.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>For his doctoral dissertation, <a href="https://gametheory.online/projects/documents/1521541344.pdf"><em>Non-Cooperative Games</em></a>.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>This fact is known as <a href="https://en.wikipedia.org/wiki/Zermelo%27s_theorem_(game_theory)">Zermelo&rsquo;s theorem</a>.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>In both <a href="https://en.wikipedia.org/wiki/Measure_(mathematics)">the mathematical</a> and informal sense.&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p>For example, <a href="https://www.youtube.com/watch?v=-aSBlRhpwVc">Christos Papadimitrou on replicator dynamics</a>.&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p>$\text{N}\small{\text{ASH}}$ asks to find a mixed-strategy NE. A pure-strategy NE is a case of a mixed-strategy NE. <a href="https://en.wikipedia.org/wiki/Zermelo%27s_theorem_(game_theory)">Zermelo&rsquo;s theorem</a> shows a pure-strategy NE always exists for the class of games in question. Then, <a href="https://en.wikipedia.org/wiki/Backward_induction">backward induction</a> algorithms can find one in linear time for finite representations of games.&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7">
<p>It is possible to obtain this number for a specific starting configuration of a Rubik&rsquo;s Cube, but no one knows the length of the longest minimal sequence of moves necessary to solve it across all starting configurations. This is somewhat dramatically known as <a href="https://web.archive.org/web/20141109174500/http://digitaleditions.walsworthprintgroup.com/article/The_Quest_For_God%E2%80%99s_Number/532775/50242/article.html">God&rsquo;s Number</a>.&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8">
<p>Term generalized from <a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2001/CSD-01-1156.pdf">its use in reinforcement learning</a>.&#160;<a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:9">
<p>This subproblem relation monomorphizes the generic formulation of the <a href="https://en.wikipedia.org/wiki/Minimax">minimax algorithm</a>.&#160;<a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:10">
<p>A parallelization plan is a data structure that can dispense information on which task must be worked on next when a parallel unit becomes available for work. It may also communicate the need to wait until another unit completes its work.&#160;<a href="#fnref:10" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
</article>

        </main><footer id="footer">
    Copyright Â© 2024 Max Fierro
</footer>
</body>
</html>
